name: Database Backup

on:
  schedule:
    # Run daily at 2 AM UTC (adjust timezone as needed)
    - cron: '0 2 * * *'
  workflow_dispatch: # Allow manual triggering
    inputs:
      backup_name:
        description: 'Custom backup name (optional)'
        required: false
        default: ''

# Grant necessary permissions for artifact operations
permissions:
  contents: read      # Allow reading repository contents
  actions: write      # Allow deleting artifacts in cleanup job
  metadata: read      # Required for API operations

jobs:
  backup:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install PostgreSQL client
        run: |
          # Install PostgreSQL 17 client to match Supabase server version
          sudo apt-get update
          sudo apt-get install -y wget ca-certificates
          wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
          echo "deb http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -cs)-pgdg main" | sudo tee /etc/apt/sources.list.d/pgdg.list
          sudo apt-get update
          sudo apt-get install -y postgresql-client-17

      - name: Create database backup
        env:
          PGPASSWORD: ${{ secrets.DATABASE_PASSWORD }}
          DB_HOST: ${{ secrets.DATABASE_HOST }}
          DB_PORT: ${{ secrets.DATABASE_PORT }}
          DB_NAME: ${{ secrets.DATABASE_NAME }}
          DB_USER: ${{ secrets.DATABASE_USER }}
        run: |
          # Create timestamp for backup file
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)

          # Use custom name if provided, otherwise use timestamp
          if [ -n "${{ github.event.inputs.backup_name }}" ]; then
            BACKUP_NAME="${{ github.event.inputs.backup_name }}_${TIMESTAMP}"
          else
            BACKUP_NAME="press_backup_${TIMESTAMP}"
          fi

          BACKUP_FILE="${BACKUP_NAME}.sql"

          echo "Creating backup: $BACKUP_FILE"

          # Create backup with connection pooling compatible settings
          pg_dump \
            --host="$DB_HOST" \
            --port="$DB_PORT" \
            --username="$DB_USER" \
            --dbname="$DB_NAME" \
            --no-password \
            --no-owner \
            --no-privileges \
            --verbose \
            --format=plain \
            --file="$BACKUP_FILE"

          # Verify backup was created and has content
          if [ ! -s "$BACKUP_FILE" ]; then
            echo "‚ùå Backup file is empty or doesn't exist!"
            exit 1
          fi

          # Get backup size
          BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
          echo "‚úÖ Backup created successfully: $BACKUP_FILE ($BACKUP_SIZE)"

          # Compress backup
          gzip "$BACKUP_FILE"
          COMPRESSED_SIZE=$(du -h "${BACKUP_FILE}.gz" | cut -f1)
          echo "‚úÖ Backup compressed: ${BACKUP_FILE}.gz ($COMPRESSED_SIZE)"

          # Save backup info for next step
          echo "BACKUP_FILE=${BACKUP_FILE}.gz" >> $GITHUB_ENV
          echo "BACKUP_SIZE=$COMPRESSED_SIZE" >> $GITHUB_ENV
          echo "BACKUP_NAME=$BACKUP_NAME" >> $GITHUB_ENV

      - name: Upload backup artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BACKUP_NAME }}
          path: ${{ env.BACKUP_FILE }}
          retention-days: 30 # Keep backups for 30 days
          compression-level: 0 # Already compressed

      - name: Backup verification
        env:
          PGPASSWORD: ${{ secrets.DATABASE_PASSWORD }}
          DB_HOST: ${{ secrets.DATABASE_HOST }}
          DB_PORT: ${{ secrets.DATABASE_PORT }}
          DB_NAME: ${{ secrets.DATABASE_NAME }}
          DB_USER: ${{ secrets.DATABASE_USER }}
        run: |
          echo "üîç Verifying backup integrity..."

          # Test that backup file can be read
          gunzip -t "${{ env.BACKUP_FILE }}"
          echo "‚úÖ Backup file integrity verified"

          # Quick verification: check that backup contains expected tables
          gunzip -c "${{ env.BACKUP_FILE }}" | grep -q "CREATE TABLE.*users"
          gunzip -c "${{ env.BACKUP_FILE }}" | grep -q "CREATE TABLE.*scrolls"
          gunzip -c "${{ env.BACKUP_FILE }}" | grep -q "CREATE TABLE.*subjects"
          echo "‚úÖ Backup contains expected database schema"

  cleanup-old-backups:
    runs-on: ubuntu-latest
    needs: backup
    if: success()

    steps:
      - name: Cleanup old backup artifacts
        env:
          GH_TOKEN: ${{ secrets.BACKUP_CLEANUP_TOKEN || github.token }}
        run: |
          # Get list of artifacts and find backup artifacts
          echo "üîç Fetching artifact list for cleanup..."
          ARTIFACTS=$(gh api repos/${{ github.repository }}/actions/artifacts --paginate --jq '.artifacts[] | select(.name | startswith("press_backup_")) | {id: .id, name: .name, created_at: .created_at}')

          # Sort by creation date (newest first) and get artifact IDs to delete
          SORTED_ARTIFACTS=$(echo "$ARTIFACTS" | jq -s 'sort_by(.created_at) | reverse')
          TOTAL_COUNT=$(echo "$SORTED_ARTIFACTS" | jq 'length')

          echo "üì¶ Found $TOTAL_COUNT backup artifacts"

          if [ "$TOTAL_COUNT" -le 7 ]; then
            echo "‚úÖ Only $TOTAL_COUNT backups found, no cleanup needed"
            exit 0
          fi

          # Get artifacts to delete (all except the newest 7)
          TO_DELETE=$(echo "$SORTED_ARTIFACTS" | jq '.[7:]')
          DELETE_COUNT=$(echo "$TO_DELETE" | jq 'length')

          echo "üóëÔ∏è  Will delete $DELETE_COUNT old backup artifacts"

          # Delete each old artifact
          echo "$TO_DELETE" | jq -r '.[].id' | while read -r artifact_id; do
            artifact_name=$(echo "$TO_DELETE" | jq -r ".[] | select(.id == $artifact_id) | .name")
            echo "Deleting artifact: $artifact_name (ID: $artifact_id)"

            if gh api --method DELETE repos/${{ github.repository }}/actions/artifacts/$artifact_id; then
              echo "‚úÖ Deleted $artifact_name"
            else
              echo "‚ùå Failed to delete $artifact_name"
            fi
          done

          echo "‚úÖ Cleanup completed - keeping 7 most recent backups"
